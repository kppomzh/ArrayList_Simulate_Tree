# 文法解析器——语法解析器的自动生成工具

## 开发构想
本项目在思路上部分仿照Antlr v4，本来计划单独写一个SQL语言解析成语法树的项目，为此重新翻书学习写教程。   
但是在重新学习的过程中，觉得即使写一个灵活的按照文法生成代码的工具似乎也并不是那么难。  
并且哪怕为是精简再精简的SQL的LL(1)文法手工构造一个分析表也是一件非常繁难艰巨毫无趣味的重复工作。于是就动了写个程序自动填分析表的念头。  
再后来想到仅仅有分析表判断语法是否正确对之后的分析工作毫无作用，于是又开始着手构造AST的数据结构；但是手动构造所有文法产生式的子AST一样也很麻烦，就再次扩展了自动填表程序的功能。  
最后想着反正语法分析的代码生成都要自动化了，索性顺手把词法分析的关键字表一起填了吧。就变成了现在这个样子。

## 功能边界确定
需要包含以下几个组件和附件：

1. 一个需要指定关键字的词法分析器
2. 一个语法分析器，包含LL(1)分析表
3. 一个AST基类
4. 一个文法规则录入工具

## 实现方式
### 1.词法分析器（Lex包）
词法分析器应该为每一个可能读取到的字符设置一个状态码，状态码是用来引导有限自动机进行状态转移的。每个状态码事实上对应了完整的有限自动机的一个子自动机，在这里表现为一个函数的形式。

由于每种单词对应的字符状态都只有几种，这样，在每个子自动机/函数内部，就可以很容易得出现在是否应该继续读入字符并且接续下去，方便进行分词。

除了符号，因为多个字符连在一起也有可能分属不同的符号单词，此时需要每次读入符号就判断一次。

需要注意的是，划分字符所属的状态时，如果两个字符的作用有任何不一致，那么一定要分到两个状态码下面去。因为如果分开的话只需要在每个子自动机里多添加一个节点两条路径；不分开的话就要在不同的节点里写逻辑判断，这样难度更大而且更容易出错。

### 2.语法分析器（Parser包）
仅由一个主控程序和一个分析表组成，根据Lex传递的符号流和分析表内容改写分析栈

工作流程为：①取符号 ②查表 ③根据分析表项改写分析栈

直到分析栈中没有符号且符号流中也没有符号为止。

分析表内容请参阅：  
https://github.com/kppomzh/Compilation_Principle/blob/master/3.1.%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F(Parser)%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9E%84%E9%80%A0.md

### 3.AST自动生成（Tree_Span包）
每个文法节点均包含三个通用protected方法：①添加子节点 ②设置属性 ③获取所有子节点

另外还有一个通用属性“节点名称”以及对应的get/set方法。

三个protected方法是用于继承并且重写的，根据每个节点的不同会有所变化。

### 4.文法规则解析（GrammarMaker包）
录入工具的主要作用就是读取文法文件。在这里，为了简化分析步骤，没有采用“文法文件内部引用文法文件”的方案，而是用了“外部配置文件依次加载文法文件”的方案；并且指定了三个必须加载的文法文件（虽然你可以不往里面写东西），依次为keyword.grammer / mark.grammer / annotation.grammer，分别代表关键字/符号/注释三类文法符号。

Reader会首先加载这三个文件并将其填到Lex中；然后按行分析grammer.list文件，从上至下加载其中的文件。

所以要求后加载的文件的所有产生式右部使用的文法符号都必须已经包含在先加载和正在加载的文件中，否则会报错表示“文法未定义”。

此后，Reader会计算所有非终结符的follow集（当然会先计算出所有first集），根据这些信息填写Parser的分析表。

再分析每个文法节点自身的性质，简化一些循环结构的子树。然后生成AST类供运行时存储分析结果。

## 未来改进计划
1. 解析文法规则的时候，可以不用显式指定最顶层的几条文法规则到一个固定的开始符号上。  
2. 增加对词法符号的分析，例如定义某些字符属于标点符号，定义另一些字符属于数的构成部分；两个分组之间可以有交集；  
同属于一个集合中的字符将会分配相同的状态码，其他未定义的符号分配默认状态码，与退出状态码相区别。  
3. 对string的定义，将会修改成允许用户自定义起止字符，以及有关标识符大小写不敏感的标记。  
4. 语法解析修改为自适应LL(k)的形式，以便解决某些不属于LL(1)但属于LL文法的表达式解析。  
5. 如果可能的话，统一分析后生成分析结果的形式。考察“反序列加载”或“Java file动态编译”哪种使用更方便。