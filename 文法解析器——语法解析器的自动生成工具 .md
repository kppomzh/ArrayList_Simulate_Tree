文法解析器——语法解析器的自动生成工具
=================

# 开发构想
本项目在思路上部分仿照Antlr v4，本来计划单独写一个SQL语言解析成语法树的项目，为此重新翻书学习写教程。   
但是在重新学习的过程中，觉得即使写一个灵活的按照文法生成代码的工具似乎也并不是那么难。  
并且哪怕为是精简再精简的SQL的LL(1)文法手工构造一个分析表也是一件非常繁难艰巨毫无趣味的重复工作。于是就动了写个程序自动填分析表的念头。  
再后来想到仅仅有分析表判断语法是否正确对之后的分析工作毫无作用，于是又开始着手构造AST的数据结构；但是手动构造所有文法产生式的子AST一样也很麻烦，
就再次扩展了自动填表程序的功能。  
最后想着反正语法分析的代码生成都要自动化了，索性顺手把词法分析的关键字表一起填了吧。就变成了现在这个样子。

# 功能边界确定
需要包含以下几个组件和附件：

1. 一个需要指定关键字的词法分析器
2. 一个语法分析器，包含LL(1)分析表
3. 一个AST基类
4. 一个文法规则录入工具

# 实现方式
## 1.词法分析器（Lex包）
词法分析器应该为每一个可能读取到的字符设置一个状态码，状态码是用来引导有限自动机进行状态转移的。每个状态码事实上对应了完整的有限自动机的一个子自
动机，在这里表现为一个函数的形式。

由于每种单词对应的字符状态都只有几种，这样，在每个子自动机/函数内部，就可以很容易得出现在是否应该继续读入字符并且接续下去，方便进行分词。

除了符号，因为多个字符连在一起也有可能分属不同的符号单词，此时需要每次读入符号就判断一次。

需要注意的是，划分字符所属的状态时，如果两个字符的作用有任何不一致，那么一定要分到两个状态码下面去。因为如果分开的话只需要在每个子自动机里多添加
一个节点两条路径；不分开的话就要在不同的节点里写逻辑判断，这样难度更大而且更容易出错。

## 2.语法分析器（Parser包）
仅由一个主控程序和一个分析表组成，根据Lex传递的符号流和分析表内容改写分析栈

工作流程为：①取符号 ②查表 ③根据分析表项改写分析栈

直到分析栈中没有符号且符号流中也没有符号为止。

分析表内容请参阅：  
https://github.com/kppomzh/Compilation_Principle/blob/master/3.1.%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F(Parser)%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9E%84%E9%80%A0.md

## 3.AST自动生成（JavaPoet包 与 Tree_Span包）
每个文法节点均包含三个通用protected方法：①添加子节点 ②设置属性 ③获取所有子节点

另外还有一个通用属性“节点名称”以及对应的get/set方法。

三个protected方法是用于继承并且重写的，根据每个节点的不同会有所变化。三个protected方法重写的规则是这样的：
### 1. 添加子节点
一般来说，如果一条文法产生式中存在表述复杂的非终结符，那么就需要添加子节点，表示这个地方还有很复杂的展开，需要继续向下寻找详细的处理过程。
如果这样的节点有很多的话，可以加一个Collection类来方便遍历；推荐用List，因为很多语言的代码顺序和处理顺序是相关的。
### 2. 添加属性
有两种情况，如果一个非终结符是由多条简单的只包含终结符的产生式组成的，那么很大概率这个非终结符代表的是某种属性。另外一种可能就是多条产生式的形式
类似，但是中间有一个关键终结符不一样，那么很可能那里就是一个属性。
### 3.获取所有子节点
将第一条所述的所有Collection类集中到一个Collection中输出。应该说这种方法不会很常用。

## 4.文法规则解析（GrammarMaker包）
### 文法节点与产生式加载
录入工具的主要作用就是读取文法文件。在这里，为了简化分析步骤，没有采用“文法文件内部引用文法文件”的方案，而是用了“外部配置文件依次加载文法文件”
的方案；并且指定了三个必须加载的文法文件（虽然你可以不往里面写东西），依次为keyword.grammer / mark.grammer / annotation.grammer，分别
代表关键字/符号/注释三类文法符号。

Reader会首先加载这三个文件并将其填到Lex中；然后按行分析grammer.list文件，从上至下加载其中的文件。

所以要求后加载的文件的所有产生式右部使用的文法符号都必须已经包含在先加载和正在加载的文件中，否则会报错表示“文法未定义”。

###first集与follow集推导
此后，Reader会计算所有非终结符的follow集（当然会先计算出所有first集），根据这些信息填写Parser的分析表。  
如果按照《编译原理》书中的文字描述直接写first集与follow集的算法也未尝不可，只是那种算法很难写，效果也不见得好；只是适合人类学习演算，而不适合
用在机器上。  
所以需要可以一次扫描就构造出所有文法符号的first集与follow集的算法。  
#### first集递推构造算法
一个文法符号的first集，可以通过深度遍历扫描其所属的所有产生式右部的第一个文法符号来获得：
1. 若右部当前符号是终结符，则直接加入左部非终结符的first集，分支遍历触底。
2. 若右部当前符号是非终结符且first集的长度大于0，则直接将first集加入左部非终结符的first集，分支遍历触底。
3. 若右部当前符号是非终结符且first集的长度为0，那么用这个非终结符的名称，继续递归的向下构造first集。并且在退出递归的时候将first集添加到左部
非终结符的信息中。

#### follow集传递构造算法
因为LL文法当中不可避免的会出现大量的ε终结符，所以follow集涉及到大量非终结符的推理判定。但是书中所述的follow集计算方法又过于繁琐，不方便进行实
现。所以在这里将会对follow集算法进行精确的描述，其中一些模糊的描述将会被精确的动作所替代。  
本算法的目的是在全局范围内，大部分节点的follow集只需要一遍计算就能得出（当然要是非搞一个到处是嵌套的文法来也没办法），局部存在循环的地方最多只
要两遍计算就能得出，避免“反复使用以上几条方法”这种没法确凿实现的语句。  
由于在最开始的时候，我们只能知道开始符号S的follow集，所以就根据follow(S)与全体符号的first集来推算全体符号的follow集。 
为了覆盖全面，构造follow集的时候，需要从开始符号S开始，用依次轮询所有产生式右部的方式逐渐的向下搜索。   
我们先规定几个符号定义：M是产生式左部的非终结符，L是某个产生式右部的一个文法符号，L+1是L右侧紧连着的第一个符号。  
由此得到follow集的一般构造算法：
1. 声明一份“无依赖文法节点”列表S。
2. 从左到右扫描每条产生式右部，当L与L+1都是非终结符的时候，记录二者的传递关系Ω(L+1,L):follow(L)=follow(L)&first(L+1)&(ε∈first(L+1)?
follow(L+1):null)，并将L+1从S中移除。
3. 从左到右扫描每条产生式右部，当L是非终结符且L+1是终结符的时候，follow(L)=follow(L)+(L+1)。
4. 扫描到产生式右部结尾的时候，若M与L都是非终结符，记录二者的传递关系Ω(M,L):follow(L)=follow(L)&follow(M)，并将L从S中移除。
5. 所有集合继承关系计算完后，首先按照链式依赖脱钩计算一遍现在已有的和将要变成的无依赖节点，这些节点必然在从根节点出发的某条没有环的路径上。
6. 计算完从根节点出发的链式依赖之后，选出所有环的代表节点，对每个环按照环式依赖脱钩的办法解开环间依赖，然后从环上每个节点单独向下进行链式依赖的
计算。
需要注意的是，2和4两条规则所存储的关系并不一样，一定不能保存在一起。

上述几条只是记录了集合间的传递关系，实际传递过程中则有链式依赖和环式依赖的不同处理方法。
链式依赖：
1. 对于链式依赖来讲，一定有一个“已经”不依赖于任何节点向它添加符号到follow集的节点。
2. 遍历这条链最简单的方法是使用递归。（目前我没有找到展开递归成递推的方法，欢迎大家进行改造）
3. 如果在遍历中，发现某个节点还存在依赖/未出现在无依赖节点列表中，那么遍历到此结束，开始向上返回。

环式依赖：（这个方法目前的算法是有缺陷的，越大的环越有可能丢失follow集符号，所以主要以学习思路为主）
以下所述的所有方法都已经在矩阵类ListMatrix中实现。
1. 获取所有能间接的连接到自身的节点集合，这些节点被称为代表节点。
2. 从某个代表节点开始，获取这个代表节点所有能（直接/间接）达到的节点中那些还能（直接/间接）达到代表节点的节点，也就是在同一个环上的所有节点。
3. 从这个代表节点开始递归遍历，运行两次，第二次开始拆除环间节点的依赖。
4. 对环上的每个节点向下进行一次链式遍历。

#### 环的判定方案
由于计算follow集的时候需要考察各节点之间的依赖顺序，所以就可能出现循环依赖的场面。
这个时候就必须采用重复计算的方法保证每个节点继承到的follow集合都是完整的
环的判定有几种方法，第一是用邻接表（经过改造）记录所有直接和间接可达的子节点；这样的优点是相对节约内存空间。
第二种方案是用可达性算法，这种方法不用对数据结构进行修改，但是不适用于可能出现大量环的场合；因为计算通路费时费力，而且很难处理一条通路上存在多个
重叠节点环的问题。
第三种方案是用邻接矩阵先记录所有直接相连的节点，然后用沃舍尔算法求传递闭包（如果需要间接连接信息）；这种方法比较消耗内存，但是运行时间只有O(n^3^)。
所以更倾向于使用第三种方案来处理环。
另外考虑到以后的扩展，可能用计数引用计算依赖会更好一点？
##### 层级树（HierarchicalTree）
该方案被否决，至少是暂时被否决。
##### 邻接矩阵
邻接矩阵类中为了调用简便减少计算量，所以有两个矩阵，一个是只有节点间直接连接关系，另一个包含了所有间接连接关系。
API如下：
1. add(K contains)：添加矩阵节点
2. addConnect(K from, K to)：添加一条直接连接
3. isConnect(K from, K to)：判断两个节点是否连接，若from或to不存在于矩阵中则直接返回false
4. getStartNodeConnects(K from,boolean directDependence)：统计from连接到的节点，directDependence为真时只考虑直接连接，为假时考虑间接连接。
5. getEndNodeConnects(K to,boolean directDependence)：作用类似上面的方法，但是方向调转为统计到达to的节点。
6. getLoops(boolean deduplication)：获取所有在环上的节点，deduplication为真时会以随机的方式清理同一条环路上的多个节点，只留下一个代表节点。
7. getOnLoopNodes(K Representative)：统计与Representative在同一个环上的所有节点，包含Representative。

### AST类生成信息采集
再分析每个文法节点自身的性质，简化一些循环结构的子树。然后生成AST类供运行时存储分析结果。  

文法节点的性质由以下几点组成：
1. 该节点是否是终结符？
2. 该节点是否是直接右递归的？（会不会循环回来）
3. 该节点是否仅仅是为了保持某些节点的循环而设计的？（消除左递归以及不定长数组）
4. 该节点是不是一个属性，或者可以表示成哪种变量的属性？
这些性质将会被填充到childNodeProperties中，并且传递给BranchTreeNode类用于生成AST类。

以上三条性质中，第一第二两条都比较好理解，第三条性质的判定方法如下：
1. ~~如果这个语法节点包含多条产生式，我们就不认为它是一个仅仅用于循环的过渡节点。~~
2. 如果一个非终结符仅包含多条有效产生式和一条空产生式，并且有效产生式是右递归的，并且以“终结符 非终结符 非终结符（本身）”的形式组织，
且每条产生式中间的非终结符都一致；即可认为它是一个过渡节点。此时将不对它生成AST类。
3. 如果一条文法产生式存在多个完全相同的子部分串联起来的话，意味着包含某些隐式的有限循环。
另外，对于类似标准SQL中union这样的结构而言，并不能算在“为了保持循环而设计”的范畴。

第四条性质的相关判定如下：
1. 假如一个非终结符中的所有产生式右部都只有一个终结符，那么这是一表示属性的非终结符。
2. 如果一条产生式右部的中间出现了一些终结符，那么多半是没有用的可以抛弃的终结符。

上面扫描完AST类的基本信息之后，就可以按照makeBranchTreeNode类中预先设置的模板方法来生成一个节点的各种对象

# 未来改进计划
1. 本质上S作为开始符号不是一个显式的过程，但是现在的实现并没有设计这部分，所以只能规定写上S的产生式并暂且规定S不能出现在任何产生式的右部；以后
解析文法规则的时候，可以不用显式指定最顶层的几条文法规则到一个固定的开始符号上。  
2. 增加对词法符号的分析，例如定义某些字符属于标点符号，定义另一些字符属于数的构成部分；两个分组之间可以有交集；  
同属于一个集合中的字符将会分配相同的状态码，其他未定义的符号分配默认状态码，与退出状态码相区别。  
3. 对string的定义，将会修改成允许用户自定义起止字符，以及有关标识符大小写不敏感的标记。  
4. 语法解析修改为自适应LL(k)的形式，以便解决某些不属于LL(1)但属于LL文法的表达式解析。  
5. 如果可能的话，统一分析后生成分析结果的形式。考察“反序列加载”或“Java file动态编译”哪种使用更方便。
6. 现在的实现没有考虑到“follow集传递构造算法”第三条中可能出现的循环依赖，以后要考虑添加进去。
7. 多个环之间的上下关系现在只是默认按照文法录入顺序来的，以后需要精确的计算一遍。