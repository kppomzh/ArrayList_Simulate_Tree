词法/语法分析生成工具将会动态的
生成一个IdentifierSetter类
生成一系列Rule_LinkedList类
生成一个分析表PredictiveAnalysisTable类
生成一系列的BranchTreeRoot类
填入对应的关键字，构造对应的文法表达式，对应的语法树
然后将这些类序列化保存到文件里；
需要使用的时候，反序列化加载出来

BranchTreeRoot类由于必须实例化并且每个语法单位的处理方法均不很一致，所以还是要考虑代码自动生成工具

固定读取annotation.grammer、keyword.grammer、mark.grammer三个文件
剩下的语法文件由grammer.list指定顺序，由上到下依次加载

first集不需要特定算法求解全集，因为在这种标准LL(k)的文法表示方法里，
first集是针对每一条产生式的，不会有针对一个非终结符下所有产生式的那种，也就是每条产生式对应一个first终结符。所以只需要造表的时候深度遍历下去就可以。
但是考虑到有些文法产生式产生ε，所以对于这些式子，必须求出其follow集。
这样当前产生式遇到follow集中的符号的时候，应该推导出ε；并且通过follow集中每一个符号归属哪条产生式，确定下一步向哪条产生式进行转移。

follow集传递算法
follow集涉及到大量非终结符的推理判定，因此可能要单独开设一个方法，对所有非终结符的follow集进行运算。
首先将所有的文法单位都记录下来（makeRule方法），记录的时候还是需要用HashMap<String,List<Rule>>
然后从S开始，S的follow集只有#，可以传递给每一个S的产生式右部的、最后一个文法符号是非终结符的文法符号。

