词法/语法分析生成工具将会动态的
生成一个IdentifierSetter类
生成一系列Rule_LinkedList类
生成一个分析表PredictiveAnalysisTable类
生成一系列的BranchTreeRoot类
填入对应的关键字，构造对应的文法表达式，对应的语法树
然后将这些类序列化保存到文件里；
需要使用的时候，反序列化加载出来

BranchTreeRoot类由于必须实例化并且每个语法单位的处理方法均不很一致，所以还是要考虑代码自动生成工具

固定读取annotation.grammer、keyword.grammer、mark.grammer三个文件
剩下的语法文件由grammer.list指定顺序，由上到下依次加载

first集在构造表的时候不需要特定算法求解全集，因为在这种标准LL(k)的文法表示方法里，
first集是针对每一条产生式的，不会有针对一个非终结符下所有产生式的那种，也就是每条产生式对应一个first终结符。所以只需要造表的时候深度遍历下去就可以。
但是考虑到有些文法产生式产生ε，所以对于这些式子，必须求出其follow集。
这样当前产生式遇到follow集中的符号的时候，应该推导出ε；并且通过follow集中每一个符号归属哪条产生式，确定下一步向哪条产生式进行转移。

first集构造算法
从梳理所有的文法产生式开始，将每条产生式的右部首符号记录在一个树结构里
然后按照深度遍历的方式遍历一次
1.若右部当前符号是终结符，则直接加入左部非终结符的first集，分支遍历触底。
2.若右部当前符号是非终结符且first集的长度大于0，则直接将first集加入左部非终结符的first集，分支遍历触底。
3.若右部当前符号是非终结符且first集的长度为0，那么用这个非终结符的名称，继续递归的向下构造first集。并且在退出递归的时候将first集添加到左部非终结符的信息中。

follow集传递算法
follow集涉及到大量非终结符的推理判定，因此可能要单独开设一个方法，对所有非终结符的follow集进行运算。
首先将所有的文法单位都记录下来（makeRule方法），记录的时候还是需要用HashMap<String,RuleInfo<Set,Set,List<Rule>>>。并且还是要统计first集。
虽然在构造表的时候应该是用不到first集（看起来像一个flag），但是构造follow集的时候还是需要的。
然后从S开始，S的follow集只有#。
我们先规定几个符号定义，然后说明也会方便一些；
M是产生式左部的非终结符，L是某个产生式右部的一个文法符号，L-1是L左侧紧连着的第一个符号

follow集在本项目中的传递算法，计算时从产生式右部的尾部向前扫描：
1.L位于结尾并且是非终结符时，M的follow集可以传递给L。记为follow(L)+=follow(M)
2.L是非终结符但是L不包含L->ε时，并且L-1也是非终结符的情况下，L只能将first集传递给L-1。记为follow(L-1)+=first(L)
3.L是非终结符但是L包含L->ε时，并且L-1也是非终结符的情况下，L将first集与follow集一起传递给L-1。记为follow(L-1)+=(first(L)+follow(L))
4.L是终结符，并且L-1也是非终结符的情况下，L加入到L-1的follow集中。记为follow(L-1)+=L

